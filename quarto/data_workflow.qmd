---
title: "Data WorkFlow"
author: "Filippo Dall'Olio"
format: 
 html:
    toc: true
    toc-location: left
    df-print: paged
    code-fold: true
    grid:
      sidebar-width: 300px
      body-width: 1400px
      margin-width: 20px
      gutter-width: 1.5rem
editor: visual
editor_options: 
  chunk_output_type: console
---

# Pakages

First, I load the required packages.

```{r}
#| output: false
devtools::install_github("f-dallolio/adtabler", quiet = TRUE)

library(tidyverse, quietly = TRUE)
library(tsibble, quietly = TRUE)
library(rlang, quietly = TRUE)
library(glue, quietly = TRUE)
library(adtabler, quietly = TRUE)
library(furrr)

```

# Data Info

Define the directory containing the AdIntel folders and retrieve data paths.

```{r}
#| output: false
adintel_dir_home <- "/mnt/sata_data_1/adintel"

adintel_folder <-list.files(adintel_dir_home, full.names = TRUE) |> 
  stringr::str_replace_all("//","/")

adintel_all_files_old <- list.files(adintel_dir_home, 
                                full.names = TRUE,
                                recursive = TRUE) 

adintel_all_files_new <- adintel_all_files_old |> 
  stringr::str_replace_all(" ", "_") |> 
  stringr::str_replace_all("//", "/")

file.rename(from = adintel_all_files_old, to = adintel_all_files_new)

adintel_all_files <- list.files(adintel_dir_home, 
                                full.names = TRUE,
                                recursive = TRUE) 
```

## Info - Dynamic Files

Retrieve file paths for 2020 "dynamic" files (i.e. they can change year by year):

```{r}
adintel_files_dyn <- adintel_all_files |> 
  str_subset(pattern = no_case("master_file"), negate = TRUE) |> 
  as_tibble_col("full_file_name") |> 
  mutate(
    year = as_numeric2(str_split_i(full_file_name, "/", -3)),
    file_type_data = str_split_i(full_file_name, "/", -2),
    file_name_data = str_split_i(full_file_name, "/", -1),
    file_type_std = rename_adintel(file_type_data),
    file_name_std = rename_adintel( str_split_i(file_name_data, "\\.", 1) ),
    .before = full_file_name
  ) |> 
  arrange(year, file_type_data, file_name_data)
```

## Info - Static Files

Retrieve file paths for "static" files (i.e. they do not change year by year):

```{r}
adintel_files_static <- adintel_all_files |> 
  str_subset(pattern = no_case("master_file")) |> 
  str_subset(pattern = no_case("Latest")) |> 
  str_subset(pattern = as.character(max(adintel_files_dyn$year))) |> 
  as_tibble_col("full_file_name") |> 
  mutate(
    year = NA,
    file_type_data = "References",
    file_name_data = str_split_i(full_file_name, "/", -1),
    file_type_std = rename_adintel(file_type_data),
    file_name_std = rename_adintel( str_split_i(file_name_data, "\\.", 1) ) ,
    .before = full_file_name
  ) |> 
  arrange(file_type_data, file_name_data)
```

# Data Description and Checks

## Description

Description of each file. The function returns a nested tibble with the name of the file (`file`), the string used (`sep`) to separate columns, the number of rows (`n_rows`), the number of columns (`n_cols`), and the column names (`col_name_man`). I use `"_man` at the end of the column indicating the column names in the original files to indicate that it is the name used in the Adintel `_man`ual. The column `col_name_std` contains standardized column names. Standardization is performed by the function `adtabler::rename_adintel()`.

The data frame `row_numbers` below is a pre-calculated table that contains the number of rows for each file. The number of rows was efficiently computed with the `read_nrows` function.

```{r}
data("row_numbers")

fn_col_info <- function(x,.name){
  df <- data.table::fread(file = x,
                          nrows = 100)
  col_name_data <- names(df)
  n_cols <-NCOL(df)
  col_pos <- seq_along(col_name_data)
  col_name_std <- rename_adintel(col_name_data)
  tibble(n_cols,
         col_pos,
         col_name_data,
         col_name_std)
}

data_info <- bind_rows(adintel_files_dyn, 
                           adintel_files_static) |> 
  mutate(data = map(full_file_name, 
                    ~ fn_col_info(.x, .name = full_file_name))) |> 
  unnest(everything()) |>
  
  inner_join( row_numbers ) |> 
  
  select(-n_lines_w_header) |> 
  relocate(n_rows, .before = n_cols) |>   
  relocate(full_file_name, .after = last_col()) 
```

## Check Against AdIntel layout Tables

```{r}
data("layout_list")
layout_list

data_info_layout <- data_info |>
  nest(.by = c(contains("_std"), col_pos)) |>
  distinct() |>
  
  inner_join(layout_list) |>
  
  arrange(row) |>
  unnest(everything())
```


```{r}
rm(list = setdiff(ls(), "data_info"))
```

## Column Description from AdIntel Manual

```{r}
data("references_columns")
data("occurrences_columns")
references_columns
# <- references_columns |> 
#   mutate(col_name_std = rename_adintel(col_name_man))
# # |> names() |> unique() |> sort()
occurrences_columns 
# <- occurrences_columns 
# |> 
#   select( - file_name_man)
# |> names() |> unique() |> sort()
# 
# 
# usethis::use_data(references_columns, overwrite = T)
# usethis::use_data(occurrences_columns, overwrite = T)

bind_rows(references_columns, occurrences_columns)
```


```{r}


data_info |> 
  nest(.by = c(file_name_std, col_pos, col_name_std)) |> 
  full_join(references_columns |> 
              mutate(col_name_std = rename_adintel(col_name_man)) |> 
               nest(.by = c(file_name_std, col_pos, , col_name_std),
                    .key = "data2")) |> 
  unnest(data2) |> 
  unnest(data)

data_info |> 
  nest(.by = c(file_name_std, col_pos, col_name_std)) |> 
  full_join(occurrences_columns |> 
              mutate(col_name_std = rename_adintel(col_name_man)) |> 
               nest(.by = c(file_name_std, col_pos, , col_name_std),
                    .key = "data2")) |> 
  unnest(data2) |> 
  unnest(data)
```

